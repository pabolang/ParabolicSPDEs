spatialPoints <- dim(dat)[2]-1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
m <- length(yWithoutBounds)
l <- lapply(yWithoutBounds, function(yy){
estimator_sigmaOneSpatialPoint(dat,yy,theta1,theta2)
})
return(sum(unlist(l))/m)
}
if(estimationMethod == "OracleKappa"){
c1 <- is.na(theta2) || is.na(sigma)
try(if(c1 && is.na(sigma0)) stop("Either provide theta2 and sigma or sigma0!"))
dat <- data
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
sigma0_Squared <- sigma^2/sqrt(theta2)
try (if(sigma0_Squared<= 0) stop("theta2 and sigma must be greater 0!"))
timeRep <- temporalPoints
time <- 1
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
y <- seq(0,1,1/xrep)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((time - spatialDelta),4))[1]-1 )]
t <- seq(0,time, 1/timeRep)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
RV(yy,y,dat = dat)
})
RV_data <- unlist(RV_list)
numeratorPart1_list <- lapply(1:m, function(k){
log(RV_data[k]/sqrt(n))*yWithoutBounds[k]
})
numeratorPart1 <- sum(unlist(numeratorPart1_list))
numeratorPart2_list <- lapply(yWithoutBounds, function(yy){
yy*log(sigma0_Squared/(sqrt(pi)))
})
numeratorPart2 <- sum(unlist(numeratorPart2_list))
numerator <- -numeratorPart1 + numeratorPart2
denominator <- sum(yWithoutBounds^2)
return(numerator / denominator)
}
if(estimationMethod == "both"){
delta <- spatialDelta
dat <- data
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
t <- seq(0,1, 1/temporalPoints)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
log(RV(yy,y,dat)/sqrt(n))
})
RV_data <- unlist(RV_list)
model <- lm(RV_data~yWithoutBounds)
sigma_hat_squared <- exp(coef(model)[1])*sqrt(pi)
names(sigma_hat_squared) <- "sigma^2_0"
kappa_hat <- -coef(model)[2]
names(kappa_hat) <- "kappa"
return(c(sigma_hat_squared,kappa_hat))
}
}
}
else{
print("Estimators by Trabs to be done!")
}
}
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa",sigma = 0.5, theta2 = 1)
est
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", theta2 = 1)
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", sigma0 = 1)
estimateParametersSPDE <- function(data, estimationMethod, spatialDelta = 0.05,theta1=NA,theta2=NA,sigma=NA,kappa=NA,sigma0_squared=NA){
RV <- function(yPoint,y,dat){
yIndex <- which(round(y,4) == round(yPoint,4))
datPath <- dat[,yIndex]
n <- length(datPath)
sum <- (datPath[2]-datPath[1])^2
for (i in 2:n) {
sum <- sum + (datPath[i]-datPath[i-1])^2
}
return(sum)
}
estimator_sigmaOneSpatialPoint <- function(dat,yPoint,theta1,theta2){
spatialPoints <- dim(dat)[2]-1
y <- seq(0,1,1/spatialPoints)
n <- dim(dat)[1]
rv <- RV(yPoint = yPoint,y = y,dat = dat)
scale <- sqrt(theta2*pi)*exp(yPoint*theta1/theta2)/sqrt(n)
return(rv*scale)
}
# Check Assumptions by Bibinger, Bossert, Trabs
if(is.list(data)){
dat <- data[[1]]
N <- dim(dat)[1] - 1
M <- dim(dat)[2] - 1
assumtionsTrue <- sqrt(N) >= M
} else {
dat <- data
N <- dim(dat)[1] - 1
M <- dim(dat)[2] - 1
assumtionsTrue <- sqrt(N) >= M
}
if(assumtionsTrue){
if(is.list(data)){
require(parallel)
require(pbapply)
require(pbmcapply)
numCores <- detectCores() - 1
if(estimationMethod == "OracleSigma"){
c1 <- is.na(theta1) && is.na(theta2)
try(if(c1) stop("Provide theta1 and theta2!"))
res <- pbmclapply(data, function(dat){
M <- dim(dat)[2]-1
spatialPoints <- M
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
m <- length(yWithoutBounds)
l <- lapply(yWithoutBounds, function(yy){
estimator_sigmaOneSpatialPoint(dat,yy,theta1,theta2)
})
sum(unlist(l))/m
},mc.cores = numCores)
return(unlist(res))
}
if(estimationMethod == "OracleKappa"){
c1 <- is.na(theta2) || is.na(sigma)
try(if(c1 && is.na(sigma0)) stop("Either provide theta2 and sigma or sigma0!"))
res <- lapply(data,function(dat){
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
if(is.na(theta2)){
sigma0_Squared <- sigma0_squared
} else {
sigma0_Squared <- sigma^2/sqrt(theta2)
}
try (if(sigma0_Squared<= 0) stop("theta2 and sigma must be greater 0!"))
timeRep <- temporalPoints
xrep <- spatialPoints
time <- 1
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
y <- seq(0,1,1/xrep)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((time - spatialDelta),4))[1]-1 )]
t <- seq(0,time, 1/timeRep)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
RV(yy,y,dat = dat)
})
RV_data <- unlist(RV_list)
numeratorPart1_list <- lapply(1:m, function(k){
log(RV_data[k]/sqrt(n))*yWithoutBounds[k]
})
numeratorPart1 <- sum(unlist(numeratorPart1_list))
numeratorPart2_list <- lapply(yWithoutBounds, function(yy){
yy*log(sigma0_Squared/(sqrt(pi)))
})
numeratorPart2 <- sum(unlist(numeratorPart2_list))
numerator <- -numeratorPart1 + numeratorPart2
denominator <- sum(yWithoutBounds^2)
numerator / denominator
})
return(unlist(res))
}
if(estimationMethod == "both"){
res <- pbmclapply(data,function(dat){
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
t <- seq(0,1, 1/temporalPoints)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
log(RV(yy,y,dat)/sqrt(n))
})
RV_data <- unlist(RV_list)
model <- lm(RV_data~yWithoutBounds)
sigma_hat_squared <- exp(coef(model)[1])*sqrt(pi)
names(sigma_hat_squared) <- "sigma^2_0"
kappa_hat <- -coef(model)[2]
names(kappa_hat) <- "kappa"
return(c(sigma_hat_squared,kappa_hat))
},mc.cores = numCores)
return(unlist(res))
}
}
else {
if(estimationMethod == "OracleSigma"){
c1 <- is.na(theta1) && is.na(theta2)
try(if(c1) stop("Provide theta1 and theta2!"))
dat <- data
spatialPoints <- dim(dat)[2]-1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
m <- length(yWithoutBounds)
l <- lapply(yWithoutBounds, function(yy){
estimator_sigmaOneSpatialPoint(dat,yy,theta1,theta2)
})
return(sum(unlist(l))/m)
}
if(estimationMethod == "OracleKappa"){
c1 <- is.na(theta2) || is.na(sigma)
try(if(c1 && is.na(sigma0)) stop("Either provide theta2 and sigma or sigma0!"))
dat <- data
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
if(is.na(theta2)){
sigma0_Squared <- sigma0_squared
} else {
sigma0_Squared <- sigma^2/sqrt(theta2)
}
try (if(sigma0_Squared<= 0) stop("theta2 and sigma must be greater 0!"))
timeRep <- temporalPoints
xrep <- spatialPoints
time <- 1
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
y <- seq(0,1,1/xrep)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((time - spatialDelta),4))[1]-1 )]
t <- seq(0,time, 1/timeRep)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
RV(yy,y,dat = dat)
})
RV_data <- unlist(RV_list)
numeratorPart1_list <- lapply(1:m, function(k){
log(RV_data[k]/sqrt(n))*yWithoutBounds[k]
})
numeratorPart1 <- sum(unlist(numeratorPart1_list))
numeratorPart2_list <- lapply(yWithoutBounds, function(yy){
yy*log(sigma0_Squared/(sqrt(pi)))
})
numeratorPart2 <- sum(unlist(numeratorPart2_list))
numerator <- -numeratorPart1 + numeratorPart2
denominator <- sum(yWithoutBounds^2)
return(numerator / denominator)
}
if(estimationMethod == "both"){
delta <- spatialDelta
dat <- data
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
t <- seq(0,1, 1/temporalPoints)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
log(RV(yy,y,dat)/sqrt(n))
})
RV_data <- unlist(RV_list)
model <- lm(RV_data~yWithoutBounds)
sigma_hat_squared <- exp(coef(model)[1])*sqrt(pi)
names(sigma_hat_squared) <- "sigma^2_0"
kappa_hat <- -coef(model)[2]
names(kappa_hat) <- "kappa"
return(c(sigma_hat_squared,kappa_hat))
}
}
}
else{
print("Estimators by Trabs to be done!")
}
}
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", sigma0 = 1)
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", sigma0_squared = 1)
estimateParametersSPDE <- function(data, estimationMethod, spatialDelta = 0.05,theta1=NA,theta2=NA,sigma=NA,kappa=NA,sigma0_squared=NA){
RV <- function(yPoint,y,dat){
yIndex <- which(round(y,4) == round(yPoint,4))
datPath <- dat[,yIndex]
n <- length(datPath)
sum <- (datPath[2]-datPath[1])^2
for (i in 2:n) {
sum <- sum + (datPath[i]-datPath[i-1])^2
}
return(sum)
}
estimator_sigmaOneSpatialPoint <- function(dat,yPoint,theta1,theta2){
spatialPoints <- dim(dat)[2]-1
y <- seq(0,1,1/spatialPoints)
n <- dim(dat)[1]
rv <- RV(yPoint = yPoint,y = y,dat = dat)
scale <- sqrt(theta2*pi)*exp(yPoint*theta1/theta2)/sqrt(n)
return(rv*scale)
}
# Check Assumptions by Bibinger, Bossert, Trabs
if(is.list(data)){
dat <- data[[1]]
N <- dim(dat)[1] - 1
M <- dim(dat)[2] - 1
assumtionsTrue <- sqrt(N) >= M
} else {
dat <- data
N <- dim(dat)[1] - 1
M <- dim(dat)[2] - 1
assumtionsTrue <- sqrt(N) >= M
}
if(assumtionsTrue){
if(is.list(data)){
require(parallel)
require(pbapply)
require(pbmcapply)
numCores <- detectCores() - 1
if(estimationMethod == "OracleSigma"){
c1 <- is.na(theta1) && is.na(theta2)
try(if(c1) stop("Provide theta1 and theta2!"))
res <- pbmclapply(data, function(dat){
M <- dim(dat)[2]-1
spatialPoints <- M
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
m <- length(yWithoutBounds)
l <- lapply(yWithoutBounds, function(yy){
estimator_sigmaOneSpatialPoint(dat,yy,theta1,theta2)
})
sum(unlist(l))/m
},mc.cores = numCores)
return(unlist(res))
}
if(estimationMethod == "OracleKappa"){
c1 <- is.na(theta2) || is.na(sigma)
try(if(c1 && is.na(sigma0_squared)) stop("Either provide theta2 and sigma or sigma0_squared!"))
res <- lapply(data,function(dat){
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
if(is.na(theta2)){
sigma0_Squared <- sigma0_squared
} else {
sigma0_Squared <- sigma^2/sqrt(theta2)
}
try (if(sigma0_Squared<= 0) stop("theta2 and sigma must be greater 0!"))
timeRep <- temporalPoints
xrep <- spatialPoints
time <- 1
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
y <- seq(0,1,1/xrep)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((time - spatialDelta),4))[1]-1 )]
t <- seq(0,time, 1/timeRep)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
RV(yy,y,dat = dat)
})
RV_data <- unlist(RV_list)
numeratorPart1_list <- lapply(1:m, function(k){
log(RV_data[k]/sqrt(n))*yWithoutBounds[k]
})
numeratorPart1 <- sum(unlist(numeratorPart1_list))
numeratorPart2_list <- lapply(yWithoutBounds, function(yy){
yy*log(sigma0_Squared/(sqrt(pi)))
})
numeratorPart2 <- sum(unlist(numeratorPart2_list))
numerator <- -numeratorPart1 + numeratorPart2
denominator <- sum(yWithoutBounds^2)
numerator / denominator
})
return(unlist(res))
}
if(estimationMethod == "both"){
res <- pbmclapply(data,function(dat){
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
t <- seq(0,1, 1/temporalPoints)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
log(RV(yy,y,dat)/sqrt(n))
})
RV_data <- unlist(RV_list)
model <- lm(RV_data~yWithoutBounds)
sigma_hat_squared <- exp(coef(model)[1])*sqrt(pi)
names(sigma_hat_squared) <- "sigma^2_0"
kappa_hat <- -coef(model)[2]
names(kappa_hat) <- "kappa"
return(c(sigma_hat_squared,kappa_hat))
},mc.cores = numCores)
return(unlist(res))
}
}
else {
if(estimationMethod == "OracleSigma"){
c1 <- is.na(theta1) && is.na(theta2)
try(if(c1) stop("Provide theta1 and theta2!"))
dat <- data
spatialPoints <- dim(dat)[2]-1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
m <- length(yWithoutBounds)
l <- lapply(yWithoutBounds, function(yy){
estimator_sigmaOneSpatialPoint(dat,yy,theta1,theta2)
})
return(sum(unlist(l))/m)
}
if(estimationMethod == "OracleKappa"){
c1 <- is.na(theta2) || is.na(sigma)
try(if(c1 && is.na(sigma0_squared)) stop("Either provide theta2 and sigma or sigma0_squared!"))
dat <- data
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
if(is.na(theta2)){
sigma0_Squared <- sigma0_squared
} else {
sigma0_Squared <- sigma^2/sqrt(theta2)
}
try (if(sigma0_Squared<= 0) stop("theta2 and sigma must be greater 0!"))
timeRep <- temporalPoints
xrep <- spatialPoints
time <- 1
delta <- spatialDelta
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
y <- seq(0,1,1/xrep)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((time - spatialDelta),4))[1]-1 )]
t <- seq(0,time, 1/timeRep)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
RV(yy,y,dat = dat)
})
RV_data <- unlist(RV_list)
numeratorPart1_list <- lapply(1:m, function(k){
log(RV_data[k]/sqrt(n))*yWithoutBounds[k]
})
numeratorPart1 <- sum(unlist(numeratorPart1_list))
numeratorPart2_list <- lapply(yWithoutBounds, function(yy){
yy*log(sigma0_Squared/(sqrt(pi)))
})
numeratorPart2 <- sum(unlist(numeratorPart2_list))
numerator <- -numeratorPart1 + numeratorPart2
denominator <- sum(yWithoutBounds^2)
return(numerator / denominator)
}
if(estimationMethod == "both"){
delta <- spatialDelta
dat <- data
try (if(delta<0 || delta >= 0.5) stop("delta needs to be greater than 0 and less than 0.5!"))
spatialPoints <- dim(dat)[2] - 1
temporalPoints <- dim(dat)[1] - 1
y <- seq(0,1,1/spatialPoints)
yWithoutBounds <- y[which(round(y,4) >= round(spatialDelta,4))[1] : (which( round(y,4) > round((1 - spatialDelta),4))[1]-1 )]
t <- seq(0,1, 1/temporalPoints)
n <- dim(dat)[1]
m <- length(yWithoutBounds)
RV_list <- lapply(yWithoutBounds,function(yy){
log(RV(yy,y,dat)/sqrt(n))
})
RV_data <- unlist(RV_list)
model <- lm(RV_data~yWithoutBounds)
sigma_hat_squared <- exp(coef(model)[1])*sqrt(pi)
names(sigma_hat_squared) <- "sigma^2_0"
kappa_hat <- -coef(model)[2]
names(kappa_hat) <- "kappa"
return(c(sigma_hat_squared,kappa_hat))
}
}
}
else{
print("Estimators by Trabs to be done!")
}
}
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", sigma0_squared = 1)
est
est <- estimateParametersSPDE(l,estimationMethod = "OracleKappa", sigma0_squared = 0.25)
est
require(ggplot2)
dat <- data.frame(x=est)
ggplot(dat,aes(sample=x))+geom_density()
?geom_density
ggplot(dat,aes(y=x))+geom_density()
ggplot(dat,aes(x=x))+geom_density()
ggplot(dat,aes(x=x,fill=1))+geom_density()
ggplot(dat,aes(x=x,fill=1))+geom_density(alpha=0.4)
ggplot(dat,aes(x=x,fill=1))+geom_density(alpha=0.4)+theme_minimal()
ggplot(dat,aes(x=x,fill=1))+geom_density(alpha=0.4)+theme_minimal()+labs(x="")
ggplot(dat,aes(x=x,fill=1))+
geom_density(alpha=0.4)+
theme_minimal()+
labs(x="")+
theme(legend.position = "none")
library("devtools")
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
setwd("/Users/patrickbosert/Desktop/Dissertation/R")
create("ParabolicSPDEs")
setwd("./ParabolicSPDEs")
document()
rm(list = c("estimateParametersSPDE"))
document()
setwd("..")
install("ParabolicSPDEs")
library("devtools")
#devtools::install_github("klutometis/roxygen")
library(roxygen2)
setwd("/Users/patrickbosert/Desktop/Dissertation/R")
create("ParabolicSPDEs")
setwd("./ParabolicSPDEs")
document()
setwd("..")
install("ParabolicSPDEs")
